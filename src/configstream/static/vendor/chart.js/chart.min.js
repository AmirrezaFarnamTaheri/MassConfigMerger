/*! Simple inline chart renderer used as a local fallback for the dashboard.
 *  This implementation intentionally exposes a very small subset of the
 *  Chart.js API that ConfigStream relies on. It focuses on the features
 *  required by the dashboard and history views (line and doughnut charts
 *  with basic dataset updates). */
(function (global) {
  'use strict';

  const DEFAULT_COLORS = [
    '#3b82f6', '#8b5cf6', '#10b981', '#f59e0b', '#ef4444', '#6366f1', '#d946ef'
  ];

  function deepClone(value) {
    try {
      if (typeof structuredClone === 'function') {
        return structuredClone(value);
      }
      return JSON.parse(JSON.stringify(value));
    } catch (err) {
      return JSON.parse(JSON.stringify(value));
    }
  }

  function resolveColor(index, fallback) {
    return fallback || DEFAULT_COLORS[index % DEFAULT_COLORS.length];
  }

  function normaliseValue(value) {
    if (value === null || value === undefined) {
      return null;
    }
    if (value instanceof Date) {
      return value.getTime();
    }
    if (typeof value === 'string') {
      const parsed = Date.parse(value);
      if (!Number.isNaN(parsed)) {
        return parsed;
      }
      const numeric = Number(value);
      return Number.isNaN(numeric) ? null : numeric;
    }
    if (typeof value === 'number') {
      return Number.isNaN(value) ? null : value;
    }
    if (typeof value === 'object' && 'x' in value && 'y' in value) {
      return { x: normaliseValue(value.x), y: normaliseValue(value.y) };
    }
    return null;
  }

  class SimpleChart {
    constructor(ctx, config) {
      if (!ctx) {
        throw new Error('A canvas rendering context is required');
      }
      this.ctx = ctx.getContext ? ctx.getContext('2d') : ctx;
      this.canvas = this.ctx.canvas;
      this.type = (config && config.type) || 'line';
      this.data = deepClone((config && config.data) || {});
      this.options = deepClone((config && config.options) || {});
      this._resizeObserver = null;
      this._boundResize = this._handleResize.bind(this);
      this._initResizeObserver();
      this.update();
    }

    _initResizeObserver() {
      if (typeof ResizeObserver !== 'undefined') {
        this._resizeObserver = new ResizeObserver(() => this._render());
        this._resizeObserver.observe(this.canvas);
      } else {
        window.addEventListener('resize', this._boundResize);
      }
    }

    _handleResize() {
      this._render();
    }

    destroy() {
      if (this._resizeObserver) {
        this._resizeObserver.disconnect();
      } else {
        window.removeEventListener('resize', this._boundResize);
      }
    }

    update(config) {
      if (config) {
        if (config.data) {
          this.data = deepClone(config.data);
        }
        if (config.options) {
          this.options = deepClone(config.options);
        }
      }
      this._render();
    }

    _ensureSize() {
      const ratio = window.devicePixelRatio || 1;
      const displayWidth = this.canvas.clientWidth || this.canvas.width || 600;
      const displayHeight = this.canvas.clientHeight || this.canvas.height || 300;
      const pixelWidth = Math.floor(displayWidth * ratio);
      const pixelHeight = Math.floor(displayHeight * ratio);
      if (this.canvas.width !== pixelWidth) {
        this.canvas.width = pixelWidth;
      }
      if (this.canvas.height !== pixelHeight) {
        this.canvas.height = pixelHeight;
      }
      this._displayWidth = displayWidth;
      this._displayHeight = displayHeight;
      this._pixelWidth = pixelWidth;
      this._pixelHeight = pixelHeight;
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.scale(ratio, ratio);
    }

    _render() {
      this._ensureSize();
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.clearRect(0, 0, this._pixelWidth, this._pixelHeight);
      const ratio = window.devicePixelRatio || 1;
      this.ctx.scale(ratio, ratio);
      if (this.type === 'line') {
        this._renderLine();
      } else if (this.type === 'doughnut') {
        this._renderDoughnut();
      }
    }

    _collectLinePoints() {
      const datasets = Array.isArray(this.data.datasets) ? this.data.datasets : [];
      const pointsByDataset = [];
      let minX = Number.POSITIVE_INFINITY;
      let maxX = Number.NEGATIVE_INFINITY;
      const axisRanges = new Map();

      datasets.forEach((dataset, index) => {
        const axisId = dataset.yAxisID || 'y';
        if (!axisRanges.has(axisId)) {
          axisRanges.set(axisId, { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY });
        }
        const range = axisRanges.get(axisId);
        const points = [];
        const rawData = Array.isArray(dataset.data) ? dataset.data : [];
        rawData.forEach((entry, idx) => {
          if (entry && typeof entry === 'object' && 'x' in entry && 'y' in entry) {
            const xVal = normaliseValue(entry.x);
            const yVal = normaliseValue(entry.y);
            if (xVal === null || yVal === null) {
              return;
            }
            minX = Math.min(minX, xVal);
            maxX = Math.max(maxX, xVal);
            range.min = Math.min(range.min, yVal);
            range.max = Math.max(range.max, yVal);
            points.push({ x: xVal, y: yVal });
          } else if (this.data.labels && this.data.labels[idx] !== undefined) {
            const xVal = normaliseValue(this.data.labels[idx]);
            const yVal = normaliseValue(entry);
            if (xVal === null || yVal === null) {
              return;
            }
            minX = Math.min(minX, xVal);
            maxX = Math.max(maxX, xVal);
            range.min = Math.min(range.min, yVal);
            range.max = Math.max(range.max, yVal);
            points.push({ x: xVal, y: yVal });
          }
        });
        pointsByDataset.push({ points, dataset, index, axisId });
      });

      if (!Number.isFinite(minX) || !Number.isFinite(maxX) || minX === maxX) {
        minX = Date.now() - 1;
        maxX = Date.now();
      }

      axisRanges.forEach((range) => {
        if (!Number.isFinite(range.min) || !Number.isFinite(range.max) || range.min === range.max) {
          range.min = 0;
          range.max = range.min + 1;
        }
      });

      return { pointsByDataset, minX, maxX, axisRanges };
    }

    _renderLine() {
      const { pointsByDataset, minX, maxX, axisRanges } = this._collectLinePoints();
      const ctx = this.ctx;
      const width = this._displayWidth;
      const height = this._displayHeight;
      const padding = 32;

      ctx.save();
      ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.stroke();
      ctx.restore();

      pointsByDataset.forEach(({ points, dataset, index, axisId }) => {
        if (!points.length) {
          return;
        }
        const range = axisRanges.get(axisId);
        const color = resolveColor(index, dataset.borderColor);
        ctx.save();
        ctx.lineWidth = 2;
        ctx.strokeStyle = color;
        ctx.beginPath();
        points.forEach((point, idx) => {
          const xRatio = (point.x - minX) / (maxX - minX || 1);
          const yRatio = (point.y - range.min) / (range.max - range.min || 1);
          const x = padding + xRatio * (width - padding * 2);
          const y = height - padding - yRatio * (height - padding * 2);
          if (idx === 0) {
            ctx.moveTo(x, y);
          } else {
            if (dataset.tension) {
              ctx.quadraticCurveTo(x, y, x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
        });
        ctx.stroke();
        if (dataset.fill && dataset.backgroundColor) {
          ctx.lineTo(padding + (points[points.length - 1].x - minX) / (maxX - minX || 1) * (width - padding * 2), height - padding);
          ctx.lineTo(padding + (points[0].x - minX) / (maxX - minX || 1) * (width - padding * 2), height - padding);
          ctx.closePath();
          ctx.globalAlpha = 0.3;
          ctx.fillStyle = dataset.backgroundColor;
          ctx.fill();
        }
        ctx.restore();
      });
    }

    _renderDoughnut() {
      const dataset = (this.data.datasets || [])[0];
      const values = (dataset && Array.isArray(dataset.data)) ? dataset.data : [];
      const total = values.reduce((acc, value) => {
        const normalised = Number(value);
        return Number.isNaN(normalised) ? acc : acc + Math.max(normalised, 0);
      }, 0);
      if (total <= 0) {
        return;
      }
      const ctx = this.ctx;
      const width = this._displayWidth;
      const height = this._displayHeight;
      const radius = Math.max(Math.min(width, height) / 2 - 16, 10);
      const centerX = width / 2;
      const centerY = height / 2;
      let startAngle = -Math.PI / 2;

      values.forEach((value, index) => {
        const numeric = Number(value);
        if (Number.isNaN(numeric) || numeric <= 0) {
          return;
        }
        const sliceAngle = (numeric / total) * Math.PI * 2;
        const color = resolveColor(index, dataset.backgroundColor && dataset.backgroundColor[index]);
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.fillStyle = color;
        ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
        ctx.closePath();
        ctx.fill();
        startAngle += sliceAngle;
      });
    }
  }

  SimpleChart.version = '3.7.1-lite';
  SimpleChart._adapters = SimpleChart._adapters || {};

  global.Chart = SimpleChart;
})(typeof window !== 'undefined' ? window : this);
